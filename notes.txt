Observations regarding HTML templates.
In base.tmpl.html, we defined a base structure which most html pages will hold within our web application. To avoid repetition and which carry out possible mistakes, we define a structure which has placeholder "title" and "main" blocks. When we actually want to write an html page, we will just execute the base template, passing as arguments (or loading into the template) the actual html blocks we want to put in place. Note that the "main" block is pretty much unlimited.

In order to actually execute these templates, we must first create a string slice with all the absolute or relative paths to both the base template and the "main" and "title blocks (its important that the first element MUST be the base template). Then, those templates and blocks are loaded using the ParseFiles function from the template package (which is part of the Go standard library) passing the slice as an argument. This returns a Template object, which holds an ExecuteTemplate method that takes an io.Writer object, the name of the template to be executed (in this case, "base"), and a list of arguments to be passed, and writes the template into the io.Writer object, replacing placeholders with their actual values.


Note on the usage of Handle vs HandleFunc in main.go. Both take a pattern to match in their first argument, the difference being in their second argument. While HandleFunc takes a function which takes an http.ResponseWriter and an http.Request and returns void, Handle takes an object that satisfies the interface http.Handler, that is, an object that implements a ServeHTTP(w http.ResponseWriter, r *http.Request) method. So they are essentially the same, but Handle is typically used when another function had created the http.Handler for us, whereas the functions passed to HandleFunc are usually user-generated. 
In fact, the implementation for HandleFunc involves wrapping the function passed as an argument into an http.Handler.
Another approach that also illustrates how these are equivalent is using the HandlerFunc adapter. HandlerFunc takes a function with the signature of ServeHTTP and returns a Handler whose ServeHTTP method is the given function. In that sense, the HandleFunc method is just syntactic sugar that transforms a function to a handler and registers it in one step.


Note on the usage of http.ServeFile() function. This is useful when, rather than setting up a fileserver for a whole directory of files (or possibly more directories, like the one we have set up for the application), you want to set up a handler that always returns the same file to a given kind of request. This is usually better when the handler should provide an specific file, like just the html for some page.


Something remarkable is that the signature for the ListenAndServe function we've been using actually takes a Handler as its second argument, and we have been passing a servemux instead. This is possible because servemux actually does implement a ServeHTTP method; in fact, we can think of a servemux just as a special kind of handler, which instead of responding to the requests, it passes the request to the appropriate handler. This is very common in Go, we will often chain handlers together.
What actually goes on is that when our server receives an HTTP request, it calls the servemux's ServeHTTP method, which looks up the correct handler to call based on the request method and URL path, and in turn calls the handler's ServeHTTP method. 
In that sense, a Go web application can be though of as a chain of ServeHTTP() methods being called one after another.
